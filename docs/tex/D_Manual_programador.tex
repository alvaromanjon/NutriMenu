\apendice{Documentación técnica de programación}

\section{Introducción}

\section{Estructura de directorios}

\subsection{Estructura de los archivos de Docker}

\dirtree{%
.1 NutriMenu.
.2 docker-compose.
.3 docker-compose.ci.yml.
.3 docker-compose.dev.yml.
.2 webapps.
.3 apirest.
.4 Dockerfile.
.4 run\_docker\_ci.sh.
.4 run\_docker\_dev.sh.
.3 frontend.
.4 .dockerignore.
.4 Dockerfile.
}

\section{Manual del programador}

\subsection{Dockerfiles}

\subsubsection{API REST}

\begin{lstlisting}
FROM eclipse-temurin:17
RUN apt update && apt -y upgrade
RUN apt install -y inotify-tools dos2unix
ENV HOME=/app
RUN mkdir -p $HOME
WORKDIR $HOME
\end{lstlisting}

A la hora de desplegar la parte de \textit{backend} disponemos para ello de un \textbf{Dockerfile}, que va a ser el encargado de definir cómo se va a crear la imagen de Docker, y qué parámetros y dependencias va a necesitar. Es el equivalente al proceso al que todos estamos acostumbrados de crear una máquina virtual, instalar el sistema operativo escogido y configurar todas las dependencias y paquetes necesarios, solo que en este caso todo esto podemos ahorrárnoslo (tanto en esfuerzo como en tiempo, ya que el tiempo de despliegue de una imagen de Docker es de apenas un par de minutos en la mayoría de los casos) escribiendo en este archivo la configuración necesaria que necesitamos para nuestro caso de uso.

En este caso me he basado en otra imagen ya existente, \textit{\textbf{eclipse-temurin}} (\href{https://hub.docker.com/layers/library/eclipse-temurin/17/images/sha256-b0faf02bf7acfc65be1c2d0a291140300bd129620f145bf1013a1da748295d0c?context=explore}{Docker Hub}), ya que contiene tanto el JDK como el JRE de Java, además de una instalación mínima de \textbf{Linux Ubuntu} con todas las dependencias ya instaladas y configuradas. He especificado que quiero usar la etiqueta \textit{\textbf{17}}, puesto que quiero usar Java 17 para este proyecto, ya que es la última versión LTS \textit{(Long Term Support)} disponible en el momento \cite{java:releases}. Existen muchas implementaciones del JDK de Java \cite{foojay:java-jdks}, pero en este caso he usado Eclipse Temurin principalmente por su soporte a arquitecturas \textit{ARMv7} y \textit{ARM64/v8}, lo que permite poder ejecutar los contenedores en plataformas como Apple Silicon, o incluso en mini-computadores como una Raspberry Pi.

Aunque la imagen descarga automáticamente la última versión disponible de \href{https://hub.docker.com/layers/library/eclipse-temurin/17/images/sha256-b0faf02bf7acfc65be1c2d0a291140300bd129620f145bf1013a1da748295d0c?context=explore}{Docker Hub}, por si acaso cada vez que construyamos la imagen vamos a comprobar si hay actualizaciones disponibles para cualquier paquete del sistema operativo del que dispone la imagen. Además de esto, también se van a instalar como dependencias \textit{\href{https://github.com/inotify-tools}{inotify-tools}}, una herramienta para monitorizar cambios en el código; y \textit{\href{https://dos2unix.sourceforge.io/}{dos2unix}}, que se encarga de cambiar el tipo de final de línea de \textbf{CRLF} (Windows) a \textbf{LF} (Unix) \cite{medium:spring-boot-in-docker}. Indicamos también que, dentro de la imagen, el directorio que vamos a usar para trabajar es \verb,/app,, puesto que esto nos permite que cualquier comando que ejecutemos a continuación se realice dentro de ese directorio \cite{docker:workdir}.

\subsubsection{Frontend} \label{dockerfile-frontend}

\begin{lstlisting}
FROM node:alpine
ENV HOME=/app
RUN mkdir -p $HOME
WORKDIR $HOME
COPY package*.json ./
RUN npm install
EXPOSE 3000
CMD ["npm", "start"]
\end{lstlisting}

En la parte del \textit{frontend} también disponemos de otro \textbf{Dockerfile}, en este caso con la imagen oficial de \textit{\textbf{Node}}, ya que es el entorno de ejecución que hay debajo de React. He usado la etiqueta \textit{\textbf{alpine}} (\href{https://hub.docker.com/layers/library/node/alpine/images/sha256-923cd6fac65f6892aa8bbb4208ad708c56b35f9ab86eca07ccc7b56dd28c9c77?context=explore}{Docker Hub}), ya que \textbf{Alpine} es una distribución de Linux orientada a ser lo más ligera posible, reduciendo el número de paquetes al mínimo y sustituyendo las herramientas GNU por \textbf{BusyBox} \cite{wikipedia:busybox}, un ejecutable que es capaz de emularlas.

Al igual que en el otro Dockerfile que acabamos de ver, he configurado el entorno de ejecución en el directorio \verb,/app, del contenedor. A continuación he indicado que quiero que se copien los archivos que empiezan por \verb,package, y acaban en \verb,.json, al contenedor, ya que en un proyecto React son los archivos que indican todas las dependencias que necesita el proyecto para poder ejecutarse. Sobre el qué directorio va a usar Docker para coger estos archivos, lo veremos después en el archivo de configuración de \textbf{Docker Compose}, puesto que al construir la imagen con la etiqueta \verb,build:, indicaremos el directorio al que puede acceder Docker durante la construcción de la imagen con el atributo \verb,context:, \cite{docker:build-context}.

Por último, la imagen va a instalar todas las dependencias del proyecto necesarias con \verb,npm install,, se va a abrir el puerto \textit{3000} del contenedor, ya que es el utilizado por React para poder acceder a la aplicación, y se va a iniciar la aplicación con el comando \verb,npm start,. 

\subsection{Docker Compose}

Dentro de los archivos de configuración de Docker Compose, situados en la carpeta \verb,docker-compose, del directorio raíz del proyecto, tenemos dos archivos distintos:

\begin{itemize}
	\item \verb,docker-compose.ci.yml,: Es el encargado de configurar los contenedores que se van a desplegar en el \textbf{entorno CI/CD configurado}, es decir, \textit{GitHub Actions}. Es prácticamente idéntico al entorno de desarrollo, tan sólo cambian las referencias a los scripts de arranque, como veremos a continuación.
	\item \verb,docker-compose.dev.yml,: Es el \textbf{entorno de desarrollo} utilizado durante la creación de esta aplicación, ya que está configurado de tal forma que permite interactuar con la aplicación y aplicar y compilar los cambios en el código en tiempo real, sin necesidad de reiniciar los contenedores, usando \textit{LiveReload} \cite{codejava:livereload}.
\end{itemize}

\subsubsection{Frontend}

\begin{lstlisting}
  frontend:
    build:
      context: ../webapps/frontend
    restart: always
    ports:
      - ${FRONTEND_DOCKER_PORT}:3000
    networks:
      - nutrimenu-net
    env_file:
      - .env
    depends_on:
      - api-rest
    volumes:
      - ../webapps/frontend:/app:rw
      - /app/node_modules
    stdin_open: true	
\end{lstlisting}

Dentro de nuestro archivo de configuración \verb,docker-compose.dev.yml, el primer servicio con el que nos encontramos es el correspondiente al contenedor encargado de desplegar la parte del \textit{frontend}. Esta parte no aparece dentro de \verb,docker-compose.ci.yml,, ya que GitHub Actions sólo está configurado para la parte del \textit{backend} y la base de datos. 

Dentro de este archivo de configuración podemos destacar algunos elementos:

\begin{itemize}
	\item Como hemos mencionado anteriormente en el apartado de los \textit{Dockerfile} \ref{dockerfile-frontend}, la etiqueta \verb,context:, en \verb,build:, indica el \textbf{directorio al que vamos a dar acceso a Docker a la hora de construir la imagen}, que en este caso es \verb,webapps/frontend,. Los dos puntos antes del directorio significan que ese directorio se encuentra fuera de la carpeta actual, \verb,docker-compose,.
	\item El contenedor está configurado para \textbf{reiniciarse de forma automática} en caso de fallo \cite{baeldung:restart-policies}.
	\item El contenedor \textbf{va a estar conectado a una red} creada también en el fichero de Docker Compose, la cual veremos a continuación.
	\item Se va a usar el fichero de \textbf{variables de entorno} descrito en el apartado \ref{entorno-desarrollo} para definir las distintas variables especificadas en este archivo.
	\item El contenedor va a esperar a que el contenedor de la \textbf{API REST} esté en estado \textit{ready} para arrancar \cite{docker:depends-on}.
	\item \textbf{Se van a crear dos volúmenes}, uno encargado de \textbf{mapear los archivos de la aplicación en local} (\verb,../webapps/frontend,) \textbf{con el directorio de trabajo dentro del contenedor} (\verb,/app,) ,indicando que este directorio va a ser tanto de lectura como de escritura; y otro volumen específico para \verb,node_modules,, \textbf{la carpeta que contiene todas las dependencias descargadas}. Este primer volumen es lo que nos permite poder realizar modificaciones sin tener que reiniciar servicios ni volver a construir imágenes, mientras que el segundo volumen se monta debido a que, cuando montamos este primer volumen, el contenido que hubiera en nuestro directorio de trabajo del contenedor (\verb,/app,) se sobreescribe por el del directorio mapeado, así que con este segundo volumen montado podemos recuperar la carpeta \verb,node_modules, generada al crear la imagen con el comando \verb,npm install,, puesto que sin esta carpeta \textbf{no podemos ejecutar la aplicación} (a no ser que hubiéramos ejecutado la app en local anteriormente y ya tuviésemos una carpeta \verb,node_modules,) \cite{stack-overflow:node_modules-folder}.
		\item \textbf{Se mantiene una entrada abierta para el contenedor}, lo que nos puede servir para poder instalar paquetes usando \verb,npm,.
\end{itemize}

\subsubsection{Backend}

\begin{lstlisting}
  api-rest:
    build:
      context: ../webapps/apirest
    restart: always
    ports:
      - ${API_WEB_DOCKER_PORT}:${API_WEB_LOCAL_PORT}
      - ${API_RELOAD_DOCKER_PORT}:${API_RELOAD_LOCAL_PORT}
      - ${API_DEBUG_DOCKER_PORT}:${API_DEBUG_LOCAL_PORT}
    networks:
      - nutrimenu-net
    env_file:
      - .env
    depends_on:
      mysqldb:
        condition: service_healthy
    working_dir: /app
    command: sh run_docker_dev.sh
    volumes:
      - ../webapps/apirest:/app
      - .m2:/root/.m2
\end{lstlisting}

Para la parte del \textit{backend} muchos de los elementos del Dockerfile son similares a los vistos en la parte del \textit{frontend}, así que simplemente destacaré aquellos que varían respecto a este:

\begin{itemize}
	\item Se van a \textbf{configurar los puertos} descritos en el apartado \ref{entorno-desarrollo}.
	\item A la hora de depender del contenedor de la base de datos para arrancar, he especificado la condición \verb,service_healthy,, que hace que no sólo el contenedor de la API espere a que el de la base de datos esté en estado \textit{ready}, sino que además \textbf{va a ejecutar un \textit{healthcheck} para comprobar que la base de datos se encuentra accesible}. Esto es \textbf{MUY importante} para el correcto funcionamiento de la app, ya que sin este \textit{healthcheck}, se puede dar el caso de que la API REST arranque antes que la base de datos, causando un error en la ejecución.
	\item Nada más arrancar \textbf{va a ejecutar el comando} \verb,run_docker_dev.sh,. Este comando lo que hace es levantar el servicio de \textit{backend} y estar a su vez a la espera de cambios en los ficheros del código fuente para, en caso de que suceda, recompilar el código de forma transparente. Este apartado es distinto en el archivo \verb,docker-compose.ci.yml,, puesto que hace referencia a \verb,run_docker_ci.sh, que simplemente compila la aplicación y la ejecuta.
	\item Se van a conectar dos volúmenes al contenedor: uno va a ser \textbf{el que contiene el código del servicio} (ya que si simplemente copiáramos el código al contenedor, cada vez que hubiera cambios en el código habría que volver a desplegar los contenedores, y de esta forma podemos realizar cambios en tiempo real); y otro va a ser \textbf{el volumen encargado de almacenar las dependencias de Maven}, para no tener que descargarlas cada vez que ejecutemos el código.
\end{itemize}

\subsubsection{Base de datos}

\begin{lstlisting}
  mysqldb:
    image: "mysql:8.0"
    restart: always
    ports:
      - ${DB_DOCKER_PORT}:${DB_LOCAL_PORT}
    networks:
      - nutrimenu-net
    env_file:
      - .env
    volumes:
      - db_data:/var/lib/mysql
    healthcheck:
      test: ["CMD", "mysqladmin" ,"ping", "-h", "localhost", "-u", "root", "-p${MYSQL_ROOT_PASSWORD}"]
      interval: 15s
      timeout: 5s
      start_period: 10s
      retries: 3
\end{lstlisting}

La base de datos también va a disponer de su propio contenedor, con ciertos parámetros similares a los de los servicios del \textit{backend}. Podemos destacar de aquí algunos elementos:

\begin{itemize}
	\item Vamos a usar la \textbf{imagen oficial de MySQL} (\href{https://hub.docker.com/layers/library/mysql/8/images/sha256-1717a37c2adc7772b569eb727bb198b6792f7d50c2adb4839ba637b5c9d88f42?context=explore}{Docker Hub}), concretamente la versión \textbf{8} (con los últimos parches). 
	\item Se va a conectar un volumen a la base de datos, que no es más que \textbf{el volumen encargado de almacenar todos los datos} de la base de datos. Esto es para no tener que inicializar la base de datos cada vez que la despleguemos, y mantener así persistencia entre sesiones.
	\item Se ha definido el \textit{healthcheck} del que hemos hablado en el apartado del \textit{backend}, que lanza un comando para comprobar que el servicio esté totalmente arrancado. Este comando se va a lanzar un máximo de 3 veces en un intervalo de 15 segundos entre una y otra, siendo la primera 10 segundos después de que arranque el contenedor, y con un timeout de 5 segundos.
\end{itemize} 

\subsubsection{Volúmenes}

\begin{lstlisting}
volumes:
  db_data:
\end{lstlisting}

Es el volumen creado para la base de datos, ya que a diferencia de los volúmenes creados para el \textit{backend}, en los que realmente hemos conectado dos carpetas de nuestro equipo a los contenedores, este volumen se crea dentro de Docker.

\subsubsection{Redes}

\begin{lstlisting}
networks:
  nutrimenu-net:
\end{lstlisting}

Esta es la red creada para conectar todos los contenedores y que no existan problemas de conectividad entre ellos.

\subsection{Configuración del debugger remoto}

Como veremos en el apartado \ref{entorno-desarrollo}, se van a configurar distintos puertos por cada uno de los servicios, y uno de estos va a ser el puerto de debug. Como vamos a ejecutar la aplicación usando Docker Compose y no compilando el código directamente desde nuestro IDE, por defecto no podemos hacer debug como haríamos con cualquier código compilado localmente. 

Sin embargo, con los pasos que vamos a ver a continuación \cite{medium:spring-boot-in-docker}, \textbf{vamos a ser capaces de conectarnos a nuestro entorno \textit{contenerizado} y realizar debug del código como lo haríamos de forma normal}. En este caso voy a demostrar cómo funcionaría en IntelliJ IDEA, pero mientras que el IDE disponga de un \textit{debugger remoto} y sigamos correctamente las instrucciones del desarrollador del IDE para usarlo, no debería de haber ningún problema.

\imagen{IntelliJ/debug-edit-conf-1}{Listado de todas las configuraciones de ejecución disponibles}{0.8}

Para comenzar, debemos de abrir  el proyecto en IntelliJ y en la parte superior, al lado de los botones de Ejecución y Debug, tenemos un selector donde podemos seleccionar la configuración que deseemos. Debemos hacer click en \textit{Edit Configurations...}.

\imagen{IntelliJ/debug-edit-conf-2}{Selección del tipo de configuración}{0.8}

Debemos hacer click en el icono con un + para añadir una nueva configuración, y seleccionar dentro del desplegable \textit{Remote JVM Debug}.

\imagen{IntelliJ/debug-edit-conf-3}{Creación de la configuración del debugger remoto}{0.8}

A continuación daremos nombre a la configuración, indicaremos el puerto correspondiente al servicio que estemos configurando, y seleccionaremos el módulo de dicho servicio.

\imagen{IntelliJ/debug-edit-conf-4}{Creación de un módulo para un servicio}{0.6}

En caso de que el módulo correspondiente no aparezca, deberemos seleccionar en la barra de herramientas \textit{File > New > Module from Existing Sources...}, seleccionar el directorio en el que se encuentre la carpeta con el servicio correspondiente, y escoger Maven dentro de \textit{Import module from external model}. Si sí que nos aparece el módulo podemos ignorar este paso.

\imagen{IntelliJ/debug-edit-conf-5}{Debug del servicio}{0.9}

Una vez hayamos completado estos pasos, podemos guardar la configuración y ejecutar el proyecto (asegurándonos de que la configuración deseada está seleccionada) desde el botón de Debug, como haríamos de normal. Si todo ha ido bien, el IDE nos devolverá en la consola el mensaje \textit{Connected to the target VM, address: 'localhost:5005', transport: 'socket'}. Hay que tener en cuenta que estos pasos se deben repetir para cada uno de los servicios, seleccionando en cada caso el puerto y módulo indicados.

\section{Compilación, despliegue y ejecución del proyecto}

Para realizar la compilación, despliegue y ejecución del proyecto es imprescindible disponer de \textbf{Docker CLI} y \textbf{Docker Compose} instalados en el equipo. La mejor forma de instalarlos es mediante \textbf{Docker Desktop}, ya que se encarga de instalar en el equipo el \textit{daemon} de Docker, Docker CLI, Docker Compose, y demás dependencias y herramientas que no vamos a utilizar para este proyecto, pero que nos pueden ayudar en el futuro. Docker Desktop es compatible con Windows, macOS y Linux, y soporta tanto arquitecturas x86 como ARM64 (Apple Silicon).

\subsection{Instalación de Docker Desktop}

\imagen{Docker/docker-download}{Página de descarga de Docker Desktop}{0.8}

Para realizar la instalación de Docker Desktop tan sólo debemos dirigirnos a \url{https://docs.docker.com/get-docker/}, seleccionar la plataforma deseada, y descargar el instalador.

\imagen{Docker/docker-installation-mac}{Instalación de Docker Desktop en Mac}{0.8}

Una vez ejecutemos el instalador (en caso de macOS simplemente se debe arrastrar la aplicación a la carpeta de Aplicaciones), y hayamos seguido todos los pasos hasta finalizar la instalación, nos encontraremos con el panel principal de Docker Desktop. 

\imagen{Docker/docker-main-window}{Ventana principal de Docker Desktop}{0.8}

En esta ventana podemos ver todos los contenedores que están ejecutándose actualmente en el sistema, así como las imágenes descargadas y los volúmenes creados.

\subsection{Preparación del entorno de desarrollo} \label{entorno-desarrollo}

Para hacer más sencillo el cambio de valores en distintos parámetros de la aplicación, como el mapeado de puertos o la gestión de secretos, y facilitar así el despliegue de nuevos entornos o la escalabilidad de los servicios, estos valores se han externalizado en un sólo archivo \verb,.env,, que va a ser un archivo que simplemente va a contener las variables junto a sus valores. 

Al ser un fichero que contiene secretos, siguiendo lo que dictan las buenas prácticas no se sincronizará con el repositorio, ya que si se tratase de un entorno de producción o el código se hiciera público, cualquier usuario podría obtener acceso a los datos de los usuarios de la aplicación.

Por lo tanto, antes de desplegar los contenedores, para que la aplicación funcione correctamente el archivo se ha de crear dentro del directorio \verb,/docker-compose,, y se deben de definir las siguientes variables dentro de él:

\begin{lstlisting}[language=Bash]
# Variables de la API REST
API_WEB_DOCKER_PORT=8080
API_WEB_LOCAL_PORT=8080
API_RELOAD_DOCKER_PORT=35729
API_RELOAD_LOCAL_PORT=35729
API_DEBUG_DOCKER_PORT=5005
API_DEBUG_LOCAL_PORT=5005

# Variables del frontend
FRONTEND_DOCKER_PORT=3000
CHOKIDAR_USEPOLLING=true

# Variables de la base de datos
DATABASE_HOST=mysqldb
MYSQL_DATABASE=nutri_db
MYSQL_USER=dbadmin
MYSQL_PASSWORD=<MySQL password> # Introduce la pass escogida para el usuario creado en el paso anterior
MYSQL_ROOT_PASSWORD=<MySQL root password> # Introduce la pass escogida para el usuario root de MySQL
DB_DOCKER_PORT=3306
DB_LOCAL_PORT=3306
\end{lstlisting}

Los valores pueden ser modificados si es necesario, pero se recomienda usar los valores dados (indicando los valores escogidos en \verb,MYSQL_USER,, \verb,MYSQL_PASSWORD, y \verb,MYSQL_ROOT_PASSWORD,). Con estos valores lo que estamos indicando es:

\begin{itemize}
	\item Los puertos en los que se van a ejecutar cada una de las aplicaciones, que en este caso van a ser el \textbf{8080} para la aplicación de gestión y el \textbf{8081} para la aplicación de los clientes.
	\item Los puertos en los que va a estar escuchando el plugin \textit{LiveReload} de Spring, que es el encargado de recargar el servidor en caliente cada vez que se produzcan cambios en el código, y no tener así que recompilar todo el código cada vez que cambiemos algo. En este caso los puertos van a ser el \textbf{35729} para la aplicación de gestión y el \textbf{35730} para la aplicación de los clientes.
	\item Los puertos que se van a usar para permitir conectar un debugger remoto a la aplicación, y poder así hacer debug desde el IDE que usemos para el desarrollo. Los puertos serán el \textbf{5005} para la aplicación de gestión y el \textbf{5006} para la aplicación de los clientes.
	\item Todas las variables correspondientes a la base de datos, como el \textbf{nombre de la instancia}, \textbf{nombre de la base de datos}, \textbf{credenciales de los usuarios de MySQL}, y el puerto escogido para la base de datos, que en este caso va a ser el usado por defecto, \textbf{3306}. 
\end{itemize}

\subsection{Despliegue de la aplicación}

\imagen{Docker/docker-compose-build}{Creación de las imágenes de los contenedores Docker}{0.8}

Una vez definidas las variables de entorno, podemos probar que todo funciona correctamente construyendo las imágenes de los contenedores de los servicios. Para ello, abriremos una consola y accederemos al directorio \verb,/docker-compose,, donde ejecutaremos el siguiente comando:

\begin{lstlisting}[language=Bash]
docker-compose build
\end{lstlisting}

\imagen{Docker/docker-compose-up}{Despliegue de los contenedores Docker}{0.8}

Para desplegar los contenedores y levantar el servicio, ejecutaremos el siguiente comando:

\begin{lstlisting}[language=Bash]
docker-compose up -d
\end{lstlisting}

\imagen{Docker/docker-desktop-containers}{Ejecución multi-contenedor de la aplicación}{0.8}

Si todo ha ido bien, podremos ver en Docker Desktop los contenedores corriendo con estado \textit{Running}, y ya podremos acceder a la aplicación como haríamos con cualquier tipo de despliegue. 

\imagen{Docker/docker-desktop-logs}{Logs de la ejecución de un contenedor en Docker Desktop}{0.8}

Para asegurarnos de que no hay ningún tipo de problema, podemos seleccionar los 3 puntos verticales situados a la derecha de cada contenedor, y hacer click en \textit{View details}, ya que esto nos permite poder ver el log de cada servicio en tiempo real. 

\section{Pruebas del sistema}
