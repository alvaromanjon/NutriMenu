\capitulo{4}{Técnicas y herramientas}

\begin{comment}
	Esta parte de la memoria tiene como objetivo presentar las técnicas metodológicas y las herramientas de desarrollo que se han utilizado para llevar a cabo el proyecto. Si se han estudiado diferentes alternativas de metodologías, herramientas, bibliotecas se puede hacer un resumen de los aspectos más destacados de cada alternativa, incluyendo comparativas entre las distintas opciones y una justificación de las elecciones realizadas. 
No se pretende que este apartado se convierta en un capítulo de un libro dedicado a cada una de las alternativas, sino comentar los aspectos más destacados de cada opción, con un repaso somero a los fundamentos esenciales y referencias bibliográficas para que el lector pueda ampliar su conocimiento sobre el tema.
\end{comment}

% TODO: Hacer introducción de esta sección %

\section{Patrón de diseño Modelo-Vista-Controlador (MVC)}

\imagen{MVC/diagrama-mvc}{Diagrama del patrón Modelo-Vista-Controlador \cite{easyappcode:mvc}}{0.9}

La función del patrón de diseño conocido como \textbf{Modelo-Vista-Controlador} es la de organizar de forma estructurada los componentes fundamentales de un determinado \textit{sistema de software}, estableciendo relaciones entre ellos.

Como metodología de trabajo, fue propuesta por Trygve Reenskaug en 1979, basándose su utilidad en tres ideas fundamentales \cite{campusmvp:mvc}:

\begin{itemize}
\item La organización y clasificación de la información que se aporta al sistema.
\item La unificación y gestión de la lógica del sistema.
\item La presentación de datos al usuario mediante una interfaz comprensible y asequible.
\end{itemize}

Los tres componentes fundamentales de este patrón tienen misiones diferenciadas sobre la forma en cómo tratan la información \cite{easyappcode:mvc}: 

\begin{itemize}
\item \textbf{Modelo}: Es el componente cuya misión es únicamente la de gestionar el contenido de una base de datos, incluida su manipulación y utilización. Es la parte que se va a encargar de la \textbf{gestión de los datos}.
\item \textbf{Vista}: Es el componente que sirve para acceder al contenido de la base de datos y presentar los datos al usuario. Va a ser \textbf{la parte con la que va a interactuar el usuario}.
\item \textbf{Controlador}: Este componente es el que pone en conexión el modelo y la vista, gestionando y procesando las instrucciones que se reciben para obtener un resultado. Su forma básica de trabajar consiste en acceder a la base de datos, manipularlos con una determinada finalidad y presentar los resultados de esa manipulación de los datos. Se va a encargar de gestionar \textbf{la lógica y la gestión de los datos}.
\end{itemize}
El motivo por el cual he decidido utilizar este patrón es porque permite trabajar de una forma precisa y eficaz, haciendo que la estructura del sistema sea clara, ordenada y separada, lo que facilita su comprensión y posterior mantenimiento.  

\section{Contenerización}

Se conoce como contenerización a la tecnología de virtualización que permite ejecutar \textbf{contenedores}, entornos completamente aislados del resto de la máquina que los está ejecutando, y que contienen todo lo necesario (bibliotecas, código, archivos de configuración, dependencias...) para que se pueda ejecutar una aplicación en cualquier entorno.\cite{microsoft:contenedores}

A diferencia de entornos clásicos de virtualización como las \textbf{máquinas virtuales}, en los que se emula el hardware por completo y se debe disponer de una instalación completa del sistema operativo para funcionar, en los contenedores se permite que múltiples instancias compartan un mismo sistema operativo, a pesar de estar usando espacios de ejecución distintos. Esto se consigue usando características de Linux como los \textit{espacios de nombres del kernel} o los \textit{cgroups} \cite{medium:kernelspace}, puesto que los contenedores están basados en Linux, pero esto no impide su ejecución en distintas plataformas y sistemas operativos, incluido Windows.
 
\subsection{Docker}

Docker es una plataforma de código abierto que permite el desarrollo, ejecución y distribución de aplicaciones en contenedores.

\subsubsection{Arquitectura de Docker}

\imagen{Docker/docker_architecture}{Arquitectura de Docker \cite{docker:overview-architecture}}{0.75}

La arquitectura de Docker es una arquitectura \textbf{cliente-servidor} \cite{docker:overview-architecture}. El cliente de Docker, que es con lo que interactúa el usuario, habla con el \textit{daemon} haciendo llamadas API REST, y este se encarga de gestionar las peticiones y los objetos de Docker, como son las imágenes, los contenedores, los volúmenes y las redes. Finalmente, para conseguir las imágenes, el \textit{daemon} habla con \textit{Docker Registry}, el repositorio que contiene todas las imágenes necesarias para el despliegue. Por defecto se usa \textbf{Docker Hub}, un repositorio público en el que cualquiera puede subir y descargar imágenes, pero se puede usar también un repositorio privado.

\subsubsection{Imágenes}

Las imágenes son plantillas que contienen instrucciones y parámetros para crear contenedores de Docker. Se puede crear un contenedor usando directamente una imagen del \textit{registry}, reutilizando imágenes ya existentes como base para crear nuestras propias imágenes, o incluso creando nuestras propias imágenes desde cero. Las imágenes se crean usando archivos \textit{Dockerfile}, añadiendo en él las distintas dependencias, instrucciones y parámetros, y cada uno de estos elementos es una capa dentro de la imagen. De esta manera, cada vez que se modifica el \textit{Dockerfile} y se vuelve a construir la imagen, realmente sólo se vuelven a construir las capas en las que han habido cambios, acelerando de esta forma el proceso de despliegue.
\cite{docker:overview-objects}

\subsection{Docker Compose}

Docker Compose es una herramienta que nos permite definir, orquestrar, desplegar y escalar \textbf{aplicaciones Docker multi-contenedor}. \cite{docker-compose:overview} Para ello, se define un archivo \textit{YAML} en el que se van a definir las  configuraciones necesarias para los distintos servicios pertenecientes a la aplicación. Esto nos va a permitir establecer relaciones y dependencias entre distintos contenedores que forman parte de un mismo aplicativo, permitiendo así que varios contenedores formen parte de una misma red o tengan la capacidad de compartir volúmenes de almacenamiento, por poner unos ejemplos.

He decidido usar esta herramienta ya que facilita bastante la conexión e integración entre los distintos servicios que componen la aplicación, como son la base de datos, el backend, y el frontend. Además de esto, a la hora de poner la aplicación en producción, obtenemos varias ventajas respecto a un entorno tradicional:

\begin{itemize}

\item \textbf{Automatización de despliegues}, ya que una vez hayamos definido en el archivo de configuración de Docker Compose todas las dependencias, configuraciones y relaciones necesarias, con un sólo comando Docker Compose se va a encargar de crear y desplegar los contenedores, configurar los elementos necesarios, e iniciar los servicios.
\item \textbf{Creación de entornos aislados y consistentes}, lo que nos permite desplegar entornos de desarrollo locales, así como entornos CI/CD de validación y pruebas, y que estos repliquen la infraestructura de producción, que también puede ser desplegada usando Docker Compose.
\item \textbf{Escalabilidad de infraestructura}, puesto que con un sólo comando podemos aumentar o disminuir el número de instancias de las que dispone un servicio.	
\end{itemize}

\section{Frameworks}

% TODO: Hacer esta parte %

\subsection{Spring Boot}

% TODO: Hacer esta parte %

\subsection{React}

% TODO: Hacer esta parte %

\subsection{JPA}

% TODO: Hacer esta parte %

\subsection{Bootstrap}

% TODO: Hacer esta parte %

\section{Gestores de paquetes}

% TODO: Hacer esta parte %

\subsection{Maven}

% TODO: Hacer esta parte %

\subsection{Node}

% TODO: Hacer esta parte %

\section{API}

% TODO: Hacer esta parte %

\subsection{Nutritionix}

% TODO: Hacer esta parte %

\section{Lenguajes de programación}

En este apartado voy a introducir y hablar un poco sobre los lenguajes de programación que he usado para el desarrollo de este proyecto:

\subsection{HTML}

El lenguaje HTML (\textit{HyperText Markup Language}) hoy en día es la base de internet, ya que es prácticamente imposible encontrar una página web que no tenga definido su contenido usando este lenguaje. Como \textbf{lenguaje de marcado} que es, utiliza marcas (etiquetas) que indican qué tipo de contenido se está representando en el navegador, lo que permite identificar y estructurar mejor este contenido, así como ser más precisos posteriormente a la hora de dar estilo a este contenido \cite{mdn:html}.

Otro de los valores fundamentales del lenguaje HTML es el \textbf{hipertexto}, que es lo que permite enlazar fácilmente contenidos, ya sea dentro de la misma página web o con otras distintas. Esto permite mejorar la forma de acceso a la información e interconectar el conocimiento, algo muy importante puesto que este es uno de los pilares básicos de internet.

Un archivo HTML sólo contiene (o debería contener, según las buenas prácticas \cite{midudev:html}) \textbf{información referente a la estructura y el contenido de la página web}, pero no información relacionada con el cómo se va a ver estructurada esta información o cómo se van a procesar los datos y se van a interactuar con ellos, puesto que eso es tarea de otros lenguajes, como CSS y JavaScript. Esto hace que, si visualizamos un archivo HTML desde el navegador que no contiene referencias a ningún otro archivo de otro lenguaje, veamos la información mostrada de forma cruda, sin ningún tipo de estilo ni distribución aplicadas mas allá que los que vienen por defecto en los navegadores.

\subsection{CSS}

Como complemento óptimo del lenguaje HTML, el lenguaje CSS (\textit{Cascading Style Sheets}) define \textbf{la estructura y los estilos utilizados en la presentación} de documentos escritos con HTML.

CSS no es un lenguaje de programación propiamente dicho ni tampoco un lenguaje de marcado, sino que es lo que se ha dado en llamar un \textbf{lenguaje de hojas de estilo}. Su funcionalidad principal es la de definir y mejorar la presentación de páginas web creadas con HTML, creando estilos y formatos que les son de aplicación \cite{mdn:css}.

De la misma forma que HTML, CSS es uno de los lenguajes más usados hoy día en el diseño de los estilos de páginas web, ya sea de forma pura o mediante el uso de distintos frameworks que facilitan su uso.

\subsection{JavaScript}

La funcionalidad principal del lenguaje JavaScript es la de mejorar la experiencia de los usuarios de páginas web, haciendo que las páginas dejen de ser estáticas para pasar a ser \textbf{interactivas y dinámicas}, lo que indudablemente las hace más atractivas e incrementa exponencialmente su funcionalidad \cite{aws:javascript}.

A diferencia de HTML, que es un lenguaje de marcado; y CSS, que es un lenguaje de hojas de estilo; JavaScript es un lenguaje de programación propiamente dicho con \textbf{compilación just-in-time}, es decir, compilación en tiempo de ejecución \cite{mdn:javascript}. Este lenguaje consta de todo lo que podríamos esperar a la hora de escribir código, desde funciones y estructuras de lógica hasta la implementación de programación orientada a objetos.

Al ser un lenguaje de programación con funcionalidad completa, no sólo se usa JavaScript para añadir funciones a las páginas web, sino que hoy en día hay aplicaciones y entornos construidos en JavaScript, como son \href{https://nodejs.org/en}{Node.js}, \href{https://code.visualstudio.com/}{Visual Studio Code}, o \href{https://www.adobe.com/es/acrobat.html}{Adobe Acrobat}. JavaScript también puede ser usado tanto en el \textbf{lado del cliente}, para añadir interactividad a la web; o en el \textbf{lado del servidor}, para manejar la lógica de la aplicación y modificar los datos de esta.

\subsection{Java}

Java es un \textbf{lenguaje de programación orientado a objetos basado en C y C++}, buscando ser similar a estos lenguajes pero haciéndolo más universal, ya que la idea de este lenguaje es que \textbf{se pueda compilar una vez y funcionar en cualquier sistema}, gracias a la implementación de la máquina virtual de Java.

 Este lenguaje es uno de los más populares y utilizados hoy en día, ya que podemos encontrarlo en prácticamente cualquier campo y ámbito, gracias a su compatibilidad, robustez, y gran cantidad de librerías y \textit{frameworks} de terceros. \cite{aws:java}
 
 En mi caso he usado este lenguaje para el desarrollo del \textit{backend}, puesto que al ser un lenguaje que ya conozco y con el que tengo experiencia, sabía 	que el usar un \textit{framework} como \textbf{Spring Boot}, así como distintas librerías como \textbf{JPA}, no iba a suponer un problema, puesto que el ecosistema Java es de los más extensos y robustos que hay ahora mismo, por lo que no voy a tener problema a la hora de buscar documentación o investigar cómo añadir una funcionalidad que me interese.

\section{Herramientas de desarrollo}

A continuación voy a proceder a describir las herramientas que me han ayudado a la hora de desarrollar este proyecto:

\subsection{Visual Studio Code}

Visual Studio Code es un \textbf{editor de código fuente gratuito y de código abierto} desarrollado por Microsoft y disponible para macOS, Windows y Linux, así como recientemente también \href{https://vscode.dev}{en versión web}.

Al ser una herramienta bastante enfocada en el desarrollo web (aunque está adaptada para el desarrollo de cualquier lenguaje), puesto que la propia aplicación está desarrollada en JavaScript, y además dispone de gran soporte en cuanto a extensiones y personalización por parte de la comunidad de desarrolladores, es una herramienta perfecta para un desarrollo como el de este proyecto, ya que dispone de un montón de herramientas que pueden agilizar y facilitar el trabajo. En mi caso esto ha sido especialmente útil a la hora de desarrollar el \textbf{frontend}, puesto que gracias al alto número de extensiones que existen en el \textit{marketplace} de Visual Studio Code he encontrado bastantes integraciones con React, como \href{https://marketplace.visualstudio.com/items?itemName=burkeholland.simple-react-snippets}{Simple React Snippets}, una extensión que permite usar abreviaciones para insertar bloques de código comunes en el desarrollo de React.

Como ya he mencionado, este IDE dispone de un montón de opciones a la hora de personalizar el entorno de programación, lo cuál sumado a las propias características de la aplicación (integración con \textit{Git}, autocompletado y resaltado de sintaxis con \textit{IntelliSense}, herramientas de debugging...) la convierten en una aplicación muy versátil \cite{vscode:main}.

\subsection{IntelliJ IDEA}

Otro IDE que he usado para poder llevar a cabo este trabajo es IntelliJ IDEA, \textbf{un editor que permite escribir código Java de forma eficaz y rápida}. 

Gracias a ser un editor de código principalmente enfocado en el lenguaje Java, presenta \textbf{características e integraciones que de normal no encontraríamos en otros editores} (aunque en editores como Visual Studio Code las podríamos llegar a asemejar mediante el uso de extensiones, pero en este editor tenemos la ventaja de que ya encontramos todo esto por defecto), como integración con los paquetes Maven, detección automática de errores, autocompletado inteligente del código... \cite{jetbrains:idea}

Esta aplicación dispone de una versión gratuita y otra de pago, pero al ser estudiante he tenido acceso a la versión completa sin coste adicional, disponiendo de todas las funcionalidades que ofrece esta herramienta. \cite{jetbrains:students}

\section{Sistema gestor de bases de datos}

En esta sección voy a describir los sistemas que he usado para todo lo que conlleva la gestión y almacenamiento de los datos de la aplicación:

\subsection{MySQL}

MySQL es un sistema RDBMS (\textit{Relational Database Management System}) gratuito (aunque dispone de una licencia empresarial) y de código abierto, y es \textbf{uno de los sistemas de administración y gestión de bases de datos más populares y utilizados}, motivo por el que lo he escogido como herramienta de trabajo.

Su funcionamiento se basa en las \textbf{bases de datos relacionales}, en las que los datos se organizan y almacenan en tablas que pueden relacionarse entre sí; y en el \textbf{modelo cliente-servidor}, en el que el servidor es el encargado de gestionar las bases de datos, y el cliente interactúa con el servidor para solicitar información, modificarla, insertarla o eliminarla mediante el uso del lenguaje SQL, permitiendo así que múltiples clientes puedan interactuar con una base de datos centralizada. \cite{wikipedia:mysql}

Algunas de las ventajas que me han hecho decantarme por este sistema son:

\begin{itemize}
  \item \textbf{Es un proyecto de código abierto, activo y con gran soporte de la comunidad}, lo que significa que va a disponer de prácticamente cualquier característica que necesite, y cualquier error va a ser solucionado lo más pronto posible.
  \item Este sistema es \textbf{conocido por su rendimiento y eficiencia}, por lo que va a poder soportar las cargas de mi aplicación sin problema alguno.
  \item \textbf{Es un sistema altamente escalable}, por lo que si en algún momento la aplicación creciese y necesitase de más potencia de procesamiento o de opciones de clusterización, sé que con este gestor no tendría ningún problema.
\end{itemize}


\section{Herramientas de gestión}

% TODO: Hacer esta parte %

\subsection{Metodología Scrum}

Para el desarrollo de este proyecto he seguido la metodología Scrum, que es una forma de trabajo que permite \textbf{gran agilidad, flexibilidad y eficiencia en la gestión de proyectos de software} \cite{atlassian:scrum}.

Un proceso Scrum \textbf{se ejecuta en base a la realización de sesiones de trabajo (\textit{sprints})} que suelen tener dos semanas de duración. Al finalizar cada sprint, se realiza la entrega específica que se ha definido y marcado inicialmente.

Previamente al inicio del sprint, se realiza \textbf{una reunión de planificación} dirigida por el responsable del proyecto (\textit{Scrum Master}), que en este caso serían los tutores del TFG, en la que se marca al \textit{Equipo de Desarrollo}, es decir, a mí, \textbf{los objetivos a cumplir durante el sprint}, la metodología de trabajo a utilizar, o se analizan y solventan las dudas y obstáculos que puedan presentarse durante el mismo.

Durante el periodo que dura el sprint, \textbf{se pueden realizar breves reuniones diarias}. En ellas se analizan los obstáculos surgidos en el día anterior y se sincronizan las actividades a realizar en ese día.

Al finalizar el sprint, \textbf{se analiza si el trabajo realizado es óptimo y se ajusta a los objetivos} planteados inicialmente. Para ello se realiza una reunión retrospectiva en la que se analiza qué ha funcionado o no, y qué es mejorable.

La utilidad de la metodología Scrum radica en varios aspectos destacables:
\begin{itemize}
  \item \textbf{Es flexible} y permite adaptarse a los cambios.
  \item Es transparente y \textbf{fomenta la comunicación entre los miembros del equipo}, lo que además redunda en una mayor colaboración entre ellos.
  \item Al final de cada sprint, \textbf{el producto final resulta mejorado e incrementado gracias a un proceso de retroalimentación}, lo que permite su mejora continua.
\end{itemize}

\subsection{Git}

Git es una herramienta inicialmente diseñada por \textit{Linus Torvalds}, la cual permite el \textbf{control de versiones} de un proyecto de software. Este sistema de control gestiona los cambios y los diferentes estados y versiones por los que pasa el código de un proyecto, por lo que es una herramienta esencial para el desarrollo de cualquier proyecto, ya sea individual o colaborativo. \cite{atlassian:git}

La base de Git son \textbf{los repositorios}, el lugar donde \textit{se va a almacenar todo el código y el histórico de cambios} que se ha producido sobre este. 

Cada desarrollador va a disponer de su propio \textbf{repositorio local}, que no es más que \textit{su copia local del código y sus cambios}, sumado a los cambios que este mismo desarrollador haya realizado. 

\imagen{git/repositorios_locales_y_remotos}{Un repositorio central y otro local, cada uno con distintos commits \cite{git:git-basics}}{1}

Además de esto, va a haber un \textbf{repositorio central}, que va a ser \textit{el lugar donde se unifican todos los cambios} que realicen los distintos desarrolladores. Los repositorios locales van a ser un \textit{clon} de este repositorio principal. Como veremos en el siguiente punto, en el caso de este proyecto el repositorio central se trata de GitHub.

\imagen{git/commits}{Distintos commits en un repositorio \cite{git:git-basics}}{1}

Los desarrolladores van a realizar los cambios e implementaciones pertinentes sobre el código, y una vez estén satisfechos con estos, van a realizar lo que se denomina como \textbf{commit}, \textit{una instantánea del código} en ese preciso momento.

\imagen{git/branches}{Ramas en un repositorio \cite{git:git-basics}}{1}

Para poder realizar modificaciones en el código sin pisar el desarrollo de otros compañeros, ni modificar el código principal de la aplicación, se da uso de lo que se denomina como \textbf{ramas o \textit{branches}}, que son \textit{versiones independientes del código en un estado concreto} (para seleccionar este momento indicamos de qué \textit{commit} partimos). Las ramas son un elemento fundamental a la hora de realizar implementaciones, experimentar con el código o simplemente hacer cambios, y son uno de los puntos clave en las buenas prácticas del desarrollo de software.

Una vez nuestros cambios estén listos, todo funcione correctamente y tengamos nuestros \textit{commits} hechos, podemos subir el código de nuestro repositorio local al repositorio central haciendo \textit{\textbf{push}}. De la misma forma, si nuestros compañeros han estado realizando cambios y queremos descargarlos a nuestro repositorio local, podemos hacerlo mediante \textit{\textbf{pull}}.

\imagen{git/merge}{Diagrama de una operación merge básica \cite{git:git-basics}}{1}

En caso de que hayamos terminado con el trabajo de una rama concreta y queramos unificar estas modificaciones a la rama principal, usaremos la operación \textit{\textbf{merge}}, que se encargará de fusionar e integrar los cambios a la rama principal. \cite{git:git-basics}

\subsection{GitHub}

\imagen{GitHub/github-repo}{Repositorio de NutriMenu en GitHub}{1}

GitHub es una plataforma web de Microsoft que permite \textbf{alojar el código de proyectos software que usen el sistema de control de versiones Git}, gestionar estos proyectos y sus tareas, y facilitar la colaboración entre usuarios.

Como GitHub actúa como un repositorio basado en Git, mediante GitHub se puede examinar todo el historial de versiones por las que ha pasado el código, volver hacia atrás en el tiempo y analizar la evolución de este. Además de esto, también permite hacer gestión de las ramas de los repositorios, con herramientas como las \textit{\textbf{pull requests}}, que permiten hacer solicitudes de \textit{merge} a los administradores de los proyectos, siendo esto un pilar fundamental en la comunidad de código abierto.

Aparte de las funciones relacionadas con Git, GitHub también ofrece herramientas para gestionar tareas, como son los \textit{\textbf{issues}}, e incluso integración con la \textit{metodología Scrum} mediante el uso de \textit{\textbf{sprints}}, lo que ha hecho que haya terminado siendo mi herramienta de elección a la hora de gestionar este proyecto, tanto a nivel de código como de gestión de trabajo y tareas \cite{wikipedia:github}.

